Strauctural Design Patterns:


S.O.L.I.D.
S – Single-responsiblity principle
O – Open-closed principle
L – Liskov substitution principle
I – Interface segregation principle
D – Dependency Inversion Principle

1. Adapter Pattern:(Wrapper : wraps the existing class with new interface)
Imcompatible Interface to be used is converted to interface expected by Client:
   Class Adapter:?
   Object Adapter: Uses Composition to contain the Adaptee(component that needs to adapt) into the Adapter( AdapterClass ) Object.
Client(Captain)---->expects(BattleShip)-------->   
               ---->BattleShipFishingBoat(adapts the interface of the Adaptee + add functions of Adaptee)------->composes of Fishing Boat(Adaptee) as private
Called by Client/is coupled to new interface  as: Captain captain = new Captain(new BattleFishingBoat());

Adapter---> after design and Bridge ---> Before
Adapter --> Aggregates incompatible and Bridge ---> Segregate Implementations
Adapter --> Different inteface, Proxy ---> Same , Decorator ---> Enhanced interfcae to Clients
Facade ---> New interface defined, Adapter ---> Older interface

2. Decorator:(SubClassing Alternative)+ Adding Responsibilities Dynamically + Wrapper(Target Object wrapped recursively)
Uses same interface as Target + composition to decorate the calls to Target.
SmartHostile(implements Hostile) is called from client passing Hostile older implementation(Troll that implements Hostile again) as constructor param.
Hostile smart = new SmartHostile(troll);

Decorator---> More transparent to Client
Decorator and Proxy----> Both provide level of indirection with implementation keeping the reference to the implementing target.
Decorator--> Upper/Skin changes and Strategy ----> Inner changes
Composite can use both chain of responsibilty and Decorator.

3.Facade: When system has large number of interdependent classes OR sourceCode is unavailable.????
Wrapper/ high level interface with set of methods required by clients and are accessed on behalf of facade client
public DwarvenGoldmineFacade() {
    workers = new ArrayList<>();
    workers.add(new DwarvenGoldDigger());
    workers.add(new DwarvenCartOperator());
    workers.add(new DwarvenTunnelDigger());
  }
 Promotes the decoupling of subsystem from clients.
 Facade--->single Object represent entire system
 FlyWeight---->Makes a lots of small Objects
 Facade oftenly Singleton as usually only 1 Facade Object required.public DwarvenGoldmineFacade() {
    workers = new ArrayList<>();
    workers.add(new DwarvenGoldDigger());
    workers.add(new DwarvenCartOperator());
    workers.add(new DwarvenTunnelDigger());
  }
 Facade -----> creates new interface 
 Adapter------> Design an existinh interface
 
  
BEHAVIOURAL DESIGN PATTERNS:
1.State Design Pattern:
Container Object/Context has an internal state Object that defines current behaviour which changes to change the behaviour of object.
This state Object can be changed to alter the behaviour, hence can be chaged at runtime.???
Mammoth is Container Object:

Mammoth has internal state that defines its behavior.
public class Mammoth {

  private State state;

  public Mammoth() {
    state = new PeacefulState(this);
  }
  
public class PeacefulState implements State {

  private Mammoth mammoth;

  public PeacefulState(Mammoth mammoth) {
    this.mammoth = mammoth;
  }
  
  Context is the single interface presented to the outer world.
  State Objects are Often Singleton.
  
  State Vs Bridge?????????
  Starategy-------> Stable Startegy,
  State ------->A Change in state of Context Object defines the Starategy to opt for.
  
  Strategy:
  Algorithm behaviour is selected at runtime.
  Capture the abstraction in an interface, bury implementation details in derived classes
  
  
  CREATIONAL PATTERN:
  1. Prototype:
   To create the new objcst by copying the prototype object
   factory = new HeroFactoryImpl(new ElfMage(), new ElfWarlord(), new ElfBeast());
    mage = factory.createMage();
    warlord = factory.createWarlord();
    beast = factory.createBeast();
    The factory prototope objects are given as parameters.
      public Mage clone() throws CloneNotSupportedException {
    return new ElfMage();
  }
Factory----> Through Inheritence
Prototype---> Through Delegation

Cloning: circular reference deep cloning could be an issue
=====================================================================================================================
2. Builder:
  seperate the complex object creation from its repreentation?
  to build different immutable objects using same object building process
  The Builder Pattern consists of a Builder, ConcreteBuilder, Director and Product.

The Director object is responsible for the construction process of the complex object but delegates the actual creation and assembly to the Builder interface.
The Builder object specifies the interface for creating parts of the complex object.
The Product represents the complex object that is created by the ConcreteBuilder objects. The Product consists of multiple parts that are created separately by the ConcreteBuilder objects.
The ConcreteBuilder objects create and assemble the parts that make up the Product through the Builder interface.
Using builder pattern to create immutable class is a good approach when the number of arguments in the Constructor is more that can cause confusion in their ordering
======================================================================================================================    
3.Object Pool: when createing the stateless object is expensive ans to be used by several Client as DB Connection
and needed for short time period . When is Object creation considered expensive: When its creation consumes a lot of memory which in turn makes program run slow.
4. singleton class: As resoucre manager, logger , configuration

IMPLEMENTATION:
1. Prototype: when a system should be independent of how its products are created, composed, and represented, and:
Classes to be instantiated are specified at run-time
http://se.cs.depaul.edu/Java/chap10.html: maze game
                                                       reading data from DB
                                                       
2.Singleton: Logger , Configuration class
3.Factory Pattern: refers to the newly created object through a common interface
4. Factory Method:????
5.Builder: the creation algorithm of a complex object is independent from the parts that actually compose the object
            eg: vehicle manufacturer
          
6. ObjectPool: reuse and share objects that are expensive to create: DB Connection.

7. Chain Of Responsibility:
           It avoids attaching the sender of a request to its receiver, giving this way other objects the possibility of handling the request too.
The objects become parts of a chain and the request is sent from one object to another across the chain until one of the objects will handle it

8. Observer:
  Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically
  News Agency: Notify the Subscriber through Email,SMS etc
  
            

